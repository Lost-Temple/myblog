---
title: Rust学习-知识点-1
tags: 
 - ref
 - 指针
 - rust
cover: 'https://s2.loli.net/2022/10/14/ydOW3hI8DkSJsrg.jpg'
categories: 
- Rust
- 基础
abbrlink: 15902
date: 2022-10-13 09:18:17
---

**&和ref的使用有什么不同，哪里需要用`&`？哪里需要用`ref`？**

---

# 一、`&`和`ref`通用的场景

先来看看第1个示例：

```rust
fn main() {
    let mut a: i32 = 1;
    let b = &a;
    println!("{}", *b); // 1

    let ref c = a;
    println!("{}", *c); // 1
}
```

示例中，`b` 和 `c` 声明的方式不同，但从结果来看并无不同，都是表示一个指针。

- 相同点：这两个指针变量都各自保存了一个内存地址，这个内存地址就是可变变量`a` 的内存地址。
- 不同点：声明方式不同，其中`let b = &a;` 和 `let ref c = a;` 这里只是语法形式上的不同；只需记忆即可

再来看第2个示例：

```rust
fn main() {
    let mut a: i32 = 1;

    let b = &mut a; // 指针 b 本身是不可以修改的，但它指向的内容是可以修改的。
    *b = 2;
    println!("{}", a); // 2

    let ref mut c = a; // 指针 c 本身是不可以修改的，但它指向的内容是可以修改的。
    *c = 3;
    println!("{}", a); //3
}
```

到这里为止，从形式表现来说有点区别，似乎作用一致，那为啥要整两个表现形式出来呢？

# 二、适合用`&`的场景

惯例，不逼逼，看示例：

```rust
fn foo(x: &mut i32) {
    *x = 666;
}
fn main() {
    let mut a: i32 = 888;
    foo(&mut a);
    println!("{}", a); // 666
}
```

人狠话不多，再看：

```rust
fn foo(ref mut x: i32) {
    *x = 666;
}
fn main() {
    let mut a: i32 = 888;
    foo(a);
    println!("{}", a); // 888
}
```

一对比，就比较明显了。经过场景一里面的例子，我们对`&` 和 `ref`的认识，感觉这两货是一个东西；但是在函数/方法签名中的应用时，就有点反直觉了。只能说rust语法规定就是这样，这是龟腚。但是我们以之前其它语言的经验来看待场景二，又会觉得这个结果很合理。

- 因为`foo(a)`的调用语义就是传入一个类型为`i32`的整型变量，而不是传入`&i32`。也就是说传入的是整型变量本身，不是传入整型变量的引用或者指针。我们再看`foo`函数的签名：`fn foo(ref mut x: i32)` ，签名中明确说传入的参数类型是`i32`，没毛病。那这个函数被调用时，内存里面到底是怎么样的呢？看现象，我觉得是这样的：调用`foo(ref mut x: i32)`时，也就是`foo(a)`，传入的是i32类型的一个变量`a`，它的值为`888`（注意不是i32变量的引用或者指针，或者说不是一个内存地址），那么会在内存栈中拷贝一个`888`这个值的副本出来放在栈中，我们可以想象成这个变量叫`a'`,这个`a'`和原来的`a`不是在一个内存地址里面，但它们的值都为`888`，我不想画图，自己想象一下吧，然后把形参`x`指向了这个副本`a'`的内存地址，然后`*x = 666`修改的是这个副本的内存地里面的值，传入的`实参888`没做修改。**不管什么语言，数据在内存中的来龙去脉想清楚非常重要，学习语法不是死记硬背，了解内存模型对掌握一门语言非常重要**
长话短说，懂的都懂：
- `foo(a)`调用时，要把`a`的值复制一份放在栈空间中，就是`a`的一个副本。`foo`函数中操作就是这个`a的副本`。你既然修改的是`a的副本`，那关`a`啥事？
- `a的副本`的值是被修改了，但是`a`的值没有被修改，所以最后打印出来的还是888

那我非要在函数/方法的参数中使用`ref`，还要达到`&`一样的效果呢？也不是不行。

**没有困难，创造困难上 —— 老子**

- 首先肯定是要改变`foo`函数的调用语义，起码要修改一下函数签名吧？函数签名中的参数类型起码得是引用吧？或者叫指针吧？
- `fn foo(ref x: &mut i32)` 这个就是我们要的修改后的函数签名
- 函数签名是有了，那么问题来了，我们给x 变量赋值应该怎么操作呢？是 `*x = 666;` 吗？那签名中的ref 不同意了：你当我不存在吗？因为这里有了`ref`，所以前面还得再加一个`*` ，仔细体会体会吧。

```rust
fn foo(ref x: &mut i32) {
    **x = 666;
}
fn main() {
    let mut a: i32 = 888;
    foo(&mut a);
    println!("{}", a); // 666
}
```
>那么问题来了，为啥这样就又可以了呢？因为形参的类型被改为了 &mut i32 了，那么调用时，foo(&mut a), 传入的是a的内存地址，而不是a变量本身，这个时候**不会发生**把这个传入的值进行拷贝一个副本存在栈中的操作。只是把形参x指向了实参a的内存地址，通俗但可能不够准确地说：x是一个指向指针的指针，也就是说 *x 代表的是 &a，**x是什么自己想想吧。

稍稍总结一下：一个`*`用来表示指针变量取到指针所指的变量，如果指针所指的变量也是个指针变量呢？那就`**`，要是指针变量指向一个指针变量再指向一个指针变量……那就是`***`。所以在函数参数声明中，一般用`&`比较多。

# 三、只能用`ref`的场景

直接上代码示例：

```rust
fn main() {
    let s = Some(String::from("Hello!"));
    match s {
        Some(t) => println!("t = {}", t),
        _ => {}
    }
    println!("s = {}", s.unwrap());
}
```

你觉得rust编译器会让你过？太天真。简简单单一段代码，涉及到了rust中的变量所有权问题。我们先来看编译器的报错结果：

```shell
   --> src/main.rs:124:24
    |
121 |         Some(t) => println!("t = {}", t),
    |              - value partially moved here
...
124 |     println!("s = {}", s.unwrap());
    |                        ^ value used here after partial move
    |
    = note: partial move occurs because value has type `String`, which does not implement the `Copy` trait
help: borrow this field in the pattern to avoid moving `s.0`
    |
121 |         Some(ref t) => println!("t = {}", t),
    |              +++

```

rust编译器就是最好最严厉的那个老师。她说的很清楚了为什么不让你通过，给你分析得明明白白，而且还给出了参考答案。

编译器大佬的意思就是说：你定义了一个变量`s`，它的值是用Some包裹的一个String类型的"Hello!"。一开始这个"Hello!"的所有权是s的。经过了match s，发现匹配到了Some(t)，也就是s里面还是有货的，这个货呢，就是"Hello!"，那现在就要把这个"Hello!"赋值给了t，这过程中就会发生变量所有权的转移：所有权由 `s` 转给了 `t`。但是编译器发现，代码最后一行，你竟然又去使用变量s，因为这个时候s所代表的Some包裹已经失去了"Hello!"的所有权。编译器认为你违反了内存安全的规则。

那么编译器既然有这个规则，不能硬来，那怎么办呢？那就不转移变量的所有权；那就要提到RUST中的借用的概念。通俗但是可能不准确的说法就是：不用变量直接进行复制操作，把变量的引用或者指针赋值给另外的变量，这就是发生了借用，但是所有权保持不变。这样就符合规则了。

那么回到示例中，关键点就是`Some(t) => println!("t = {}", t)`这句语句有问题，那我们就要对它进行改造，编译器老师都已经告诉我们怎么改造了。就是改为：`Some(ref t) => println!("t = {}", t)`

那有人会问，我能这样改造吗？`Some(& t) => println!("t = {}", t)` ，我也想这样，无奈编译器不答应啊。这也能理解：

- s变量是一个 Some 类型的值， 这个Some里面要么是String类型，要么是None ，但是不能是 &String 类型。所以match s的时候，类型要匹配上。
- 那么现在Some(ref t)，t 有 ref 的加持，这里就表示是借用，借用就不会发生所有权从s到t的转移，例子中也符合rust的借用规则，编译器老师就会让你通过考核。

我非要用&呢？也不是没有办法，还有一个变通的办法。既然问题根源是s的所有权问题，那我就直接在借用s，而它内部包裹的String变量自然而然也不会发生所有权转移。这不就从根源是解决问题了？浅尝试一下：

```rust
fn main() {
    let s = Some(String::from("Hello!"));
    match &s {
        Some(t) => println!("t = {}", t),
        _ => {}
    }
    println!("s = {}", s.unwrap());
}
```

# 四、更多的例子

```rust
fn main() {
    let v = 123;

    let x: &i32 = &v; // OK!
    let x: &i32 = &(123 + 456); // OK!
    if let Some(x) = Some(123) {} // OK!

    let ref x: i32 = v; // OK!
    let ref x: i32 = 123 + 456; // OK!
    if let Some(ref x) = Some(123) {} // OK!

    if let Some(x: &i32) = Some(&123) {} // Error！
}
```

# 五、指针变量的解引用

以下操作，`@cpp`,rust自动解多层嵌套引用大法，妈妈再也不用我数错`*`个数了

```rust
fn main() {
    let a: &i32 = &123;
    let b: &&i32 = &a;
    let c: &&&i32 = &b;

    println!("a = {}, b = {}, c = {}", a, b, c);
    println!("*a = {}, **b = {}, ***c = {}", *a, **b, ***c);
}

/* output
a = 123, b = 123, c = 123
*a = 123, **b = 123, ***c = 123
*/
```

